### 3 ноября 2021

Проект работает поверх NestJS, база данных MongoDB.
Проект работает в режиме Monorepo, имеет 2 разделенных микросервиса.
Микросервисы не общаются между собой.
Микросервис-агрегатор собирает данные, а микросервис-апи - их отдает. 
Структура стандартная для NestJS, могут быть нюансы что что-то сгруппировано в папки,
но на этом всё.
Апи-сервис содержит NextJS как фронт, подключается в `/apps/api/src/view/`.
Также проект содержит в себе и фронтенд в папке `apps/frontend`.                                                     

### Агрегатор

Данные которые мы агрегируем:  
- Текущий фандинг в данный момент времени, на каждой итерации мы его обновляем.  
- История фандинга.  

Агрегатор имеет общий абстрактный класс, описывающий общий, но простой интерфейс взаимодействия.
Смотри `apps/aggregator/src/market/abstract-market.service.ts`  

Рядом находятся два непосредственных агрегатора.  

- dYdX по сути просто обращается к их централизованному апи и получает данные. Историю фандинга, при её отстутствии,
  мы выгружаем циклом, до тех пор пока не загрузим самую старую. После, как только в базе что-то есть - загружаем
  уже только недостающий дифф. Есть слабое место - если на пустую базу данных пытаться закачать данные и тут же
  прервать процесс - самые старые в базу не попадут, а после перезапуска система будет считать что нужны только
  новые данные т.к. в базе уже что-то есть. Это не очень опасное место, но при локальной разработке можно словить,
  дабы не дебажить что пошло не так - пишу это здесь.
                                                                                      

- Perp работает сложнее - загружаются адреса контрактов файлом из их сайта, смотри константу `V1_METADATA_URL`.
  Они кешируются, если у них там что-то важное изменится - нужен перезапуск сервиса. На это есть тикет.
  Например при добавлении новой пары. Сейчас это никак не реализовано, но имеет смысл реализовать в будущем.
  Ближайший фандинг мы получаем по хитрой формуле, общаясь с блокчейном, формулу можно посмотреть в коде,
  либо обратится в чат к команде Perp, у нас есть с ними общий чат для интеграции.
  Историю мы получаем из TheGraph, смотри константу `V1_THE_GRAPH_API`.
  При этом сейчас реализована активная на данный момент версия 1, но на момент написания документации
  они уже собирались переходить на новую версию 2, оттого там и префиксы. Версия 2 обещается быть значительно
  другой.
  
Агрегаторы запускаются бесконечным циклом в `apps/aggregator/src/aggregator.service.ts`.

### Апи

Апи-сервис состоит из 3х частей.

- NextJS для рендеринга фронта. Сам же фронт хранится в папке `apps/frontend`.
  Всё что относится к подключению фронта содержится в папке `apps/api/src/view`.
  Там всё достаточно стандартно и это лишь, по сути, бинд фронта к беку.
                

- Фандинг-логика. Содержит GraphQL резолверы и сервис логики,
  сгруппированы в папке `apps/api/src/funding`.
  Вообще это не самый правильный вариант т.к. внутри должен быть модуль и он уже
  должен подключаться к рутовому модулю. А рядом находящиеся резолверы подписки на
  почту - совсем лишние. Но это легко исправить и, хорошо бы, это сделать,
  на это есть тикет.
                                         

- Подписка на письма, GraphQL резолвер, лежит вместе с фандингом. В фандинг-сервисе
  хранит и саму логику подписки.
  
### Модели данных

Также есть шаред-модели, самих данных в базе, резолверов и всякие декларативные описания
типов и интерфейсов. Всё это используется по всему приложению, может использоваться и на фронте.
Содержится в папке `libs/shared`.
Используется двойной биндинг моделей - класс с полями, которые помечены декораторами, сразу двумя,
и для базы данных, и для GraphQL. Также есть специализированные утилиты и модели для того чтобы
выдавать данные с пагинацией, смотри `libs/shared/src/list.dto.ts`.

### Библиотека работа с биржами

Также имеется не законченная библиотека для работы с биржами. Основная философия заключалась в том, чтобы
сделать унифицированное апи к биржам, по единому интерфейсу взаимодействия, а под капотом конкретные
части делали бы то что нужно. При этом предполагалось что библиотека будет работать на фронте.
Всё что есть сейчас содержится в `libs/stock`.
                                                     




